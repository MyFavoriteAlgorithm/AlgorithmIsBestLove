'''
문제
정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

X가 3으로 나누어 떨어지면, 3으로 나눈다.
X가 2로 나누어 떨어지면, 2로 나눈다.
1을 뺀다.
정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 
연산을 사용하는 횟수의 최솟값을 출력하시오.

입력
첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.

출력
첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.
'''
n = int(input())
count = [0] * (n+1) # 계산된 값 저장리스트. 계산하기 편하게 n+1로 인덱스 맞춤
#print(count)
for i in range(2, n+1): # i 는 i에서 구하는 계산수의 최솟값
    # 현재의 수(i)에서 1을 빼는 경우
    count[i] = count[i-1] + 1 # i-1 계산수에 1 추가(1만 빼면 그 값에서의 최솟값이 저장되있기 때문)
    
    # 현재의 수(i)가 3으로 나누어떨어지는 경우
    if i % 3 == 0:
        # 1만 빼는 경우와 3으로 나눈 경우 중 최솟값 선택
        count[i] = min(count[i], count[i//3] + 1 )
        # 1만 빼는 경우는 이미 +1 했기 때문에 3으로 나눈 계산수에만 +1
        
    # 현재의 수(i)가 2로 나누어 떨어지는 경우
    if i % 2 == 0:
        count[i] = min(count[i], count[i//2] + 1)
        # 위와 동일
    

print(count[n])

'''
# Dynamic Progamming 동적계획법
큰 문제를 작은 문제로 나누어 푸는 알고리즘

다음과 같은 조건에서 사용
* 큰 문제를 작은 문제로 나눌 수 있다.
* 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다
* 따라서 DP는 작은 문제의 결과를 저장해두었다가, 같은 작은 문제가 나타날때마다
이를 활용하여 문제를 풀 수 있다.
* 메모리 공간을 사용하여 시간 복잡도를 줄인다. O(n^2)->O(f(n))

구현방법:
1. 작은 문제로 나눈다.
2. 작은 문제를 풀어 답을 저장한다.
3. 큰 문제를 작은 문제로 나누어 1~3을 반복

시간복잡도:
작은 문제의 수와 작은 문제를 푸는 시간의 곱이 된다.
n = 문제의 크기, k = 작은 문제의 수
O(n*k)
'''
